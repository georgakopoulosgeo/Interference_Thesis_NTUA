
===============================
Replica-Aware Slowdown Predictor
===============================

ğŸ“Œ Purpose:
Predict normalized tail-latency slowdown (norm_perf = baseline_P99 / observed_P99)
based on live Intel PCM hardware metrics, replica count, and RPS.

ğŸ¯ Inputs to the Model:
- Sliding-window statistics (mean, std, p95) from Intel PCM logs
  â€¢ Metrics include IPC, L2MISS, L3MISS, PhysIPC%, and C-state residencies
  â€¢ Computed per core (3, 4, 5) and also as averaged aggregates
- Given RPS (traffic load)
- Number of replicas already placed on the node

ğŸ¯ Output:
- Predicted normalized slowdown (norm_perf), e.g., 1.2 â†’ 20% latency increase

ğŸ§  Model Architecture:
- StandardScaler: normalizes all input features
- PolynomialFeatures (degree=2): captures interactions between metrics
- PCA: reduces dimensionality while retaining 95% variance
- RandomForestRegressor: robust nonlinear predictor

ğŸ“ Saved Model:
- Path: models/slowdown_predictor.pkl
- Format: scikit-learn Pipeline (joblib)

ğŸ“Š Evaluation Summary:
- RÂ² Score: High (â‰ˆ 0.95 on test set)
- MAE: Low (â‰ˆ 0.04)
- PCA retained variance: 95%

ğŸ” Training Dataset:
- Derived from 24 test scenarios across 4 replica levels, 9 RPS values, and multiple interference setups
- Each sample summarizes a 180s workload run via 36-row PCM log

ğŸ”„ Use Case in Scheduler:
At pod placement time:
  1. Collect live PCM metrics
  2. Add intended replica count and known/forecasted RPS
  3. Predict expected slowdown (norm_perf)
  4. Compute RiskScore = 1 / norm_perf
  5. Choose node with lowest RiskScore

===============================
ğŸ”§ Recommendations for Improvement
===============================
1. ğŸ” Feature Selection:
   - Consider using mutual information or SHAP values to prune weak features
   - Try ablation testing to confirm which PCM metrics matter most

2. ğŸ§ª Data Expansion:
   - Run more scenarios (especially for overlapping RPS/replica ranges)
   - Add controlled noise or jitter to simulate real-world metrics

3. ğŸŒ² Model Alternatives:
   - Try XGBoost or LightGBM with early stopping
   - Consider a model ensemble (RandomForest + XGBoost + Ridge)

4. ğŸ” Drift Detection:
   - Monitor real vs. predicted norm_perf over time in production
   - Trigger retraining when drift exceeds a threshold

5. âš™ï¸ Multi-Objective Extension:
   - Extend model output to include energy or cost if system metrics allow
   - Useful for joint optimization (latency vs. energy vs. placement density)

6. ğŸ“ˆ SHAP Analysis:
   - Use TreeExplainer for detailed feature attributions
   - Plot feature importances to drive system tuning



=======================================================================
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score

X = df_ml[feature_cols]
y = df_ml["norm_perf"]

X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)

model = XGBRegressor(
    n_estimators=200,
    max_depth=4,
    learning_rate=0.05,
    subsample=0.9,
    colsample_bytree=0.8,
    reg_lambda=1.0,
    random_state=42
)

model.fit(X_train, y_train, early_stopping_rounds=10, eval_set=[(X_test, y_test)], verbose=True)

y_pred = model.predict(X_test)
print("MAE:", mean_absolute_error(y_test, y_pred))
print("RÂ²:", r2_score(y_test, y_pred))
